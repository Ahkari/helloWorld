首先,
欢迎大家来参加这次的培训，说是培训，其实我希望是个比较随意的探讨会.
大家有什么见解或是想说的都可以说, 我们可以一起探讨这些问题. 
这是我的名字和我的联系方式,有兴趣私下里也可以找我.

课程开始前,我想说下我对今天内容的总体感觉,应该是越往后越枯燥,越无聊,所以我尽量把重点部分说得详细点,其余的就靠大家自己发挥脑补能力了啊.

或者结束后我单独给你补补.

而且我是基本不会中途提问的, 大家可以抱着放松的心态来听.

那课程开始吧

这段时间对于前端测试进行了调研，试验了一些测试方案和框架，也自己思考了些常见的问题。
我会在这个培训过程中介绍自己对前端以及前端测试的理解,并给出自己总结的,适合工作中,那种常见web项目的测试解决方案。

首先我们往远了扯,
我们要像高逼格的发布会什么一样来看行业格局,

因为我们要测前端, 我们就得知道什么是前端.
前端开发, 作为近些年一个相对较新的职位, 她从网页制作中分离出来, 主要职责是网站的前台代码的实现.  具体就是实现设计师给我们的网站效果图,实现交互设计师给出的交互示意图, 再和后端同学一起同步, 将整个流程串通起来.
得到我们的最终web页面.

这是一个流传很广的图, 就是优秀的前端工程师的技能树
怎么样,
是不是觉得前端开发懂得好多, 好厉害, 顺便也把面前这位自称搞前端的也崇拜的一番?

实际上上面一半以上的我都没听过, 

难怪我不是个大神, 是吧.

我们并不需要妄自菲薄, 术业有专攻, 再复杂的系统我们都会有方法测试的, 

测服务端的X-shell远程个linux, 测接口的ruby写个脚本, 测安卓的进adb敲命令, 在其他人看起来都是好厉害的样子,

那么业界人士普遍认为怎么测前端呢?
他们认为, 前端是一种特殊的GUI软件,

GUI（Graphical User Interface，图形用户界面）是计算机软件与用户进行交互的主要方式。GUI软件测试是指对使用GUI的软件进行的软件测试。

我们需要认识到,凡是涉及GUI的测试, 成本都不会低, 而且业界号称实现自动化测试也是针对项目中20%的稳定代码实现的, 剩下的80%又臭又硬的那些代码, 反复迭代反复变更, 基本谈之色变.

在那些极其重视用户体验的互联网公司, 他们基于GUI测试, 基本有两种测试方案, 

一种就是左边这个, 所谓的超级工位大法, 
摆上一大片不同设备, 统一接到测试控制机上来执行测试, 

[一个前辈说过一句话糙理不糙的比喻, 就是前段测试就是吃翔, 这个方法就是提供了一个好点的餐位]

右边这个, 稍微靠谱点, 就是检测页面的异同, 要么是检测DOM节点树的差异, 要么就是直接前后截图的图形差异检测, 这就需要远比开发要求还要高的代码能力了.

[大家还要听话糙理不糙的比喻么? 就是这个方法还是吃, 但是让它变得不那么难吃了 ]

讲到这里估计大家都会有点害怕了, 前端测试这么麻烦, 还测个毛啊, 
所幸的是什么呢?

我们公司大部分的web测试, 都是面对这样的, 或是这样的, 或是这样的系统来测得,
他们有理可循, 条理清晰, 不直接面对互联网群众, 没有各种各样的用户体验的诉求, 

我们今天培训的目的呢, 就是基于这些公司典型的web系统进行测试, 
同样,
我们的测试是基于前端最重要的语言, 也就是javascript的，所以我们使用的工具选择也是尽量往javascript上靠拢。

目标是由开发牵头，编写出可测试，或是说适合测试的javascript代码，
这个可测试涉及到方方面面，比方注释，语法，依赖耦合的处理等。
最终让测试们从白盒，黑盒等各个方面对web前端部分进行测试。
从而提升我们的软件质量。

所以大家也应该知道了，我们今天的分享涉及的东西对于从没接触过这方面的人来说或许会有点多。
不过总体上是这六个方面，其中集成测试，单元测试和代码优化是重点。
我们从总体到局部，从系统层面的测试到代码层面进行测试。

对了，考虑到来参加分享的人岗位不同，我统计下好吧。

在座的研发人员有多少？

在做的测试人员有多少？

哦。看起来测试人员稍微多一点，那我侧重点就偏测试这边吧。

我们来看今天可能会了解的东西，工具和语言如左边所示，名词和思想如右边列举的。
我们慢慢来看。

下面是第一部分，也就是看起来有趣，让人兴奋的前端自动化测试。
说起自动化测试，在座的一定不陌生，直观点说，就是测试人员点下开始键，测试用例自己运行打印结果。
实际工作中想必和这个愿景差之甚远吧，据我了解，大部分的测试人员还是手工点击执行用例为主。


倒不是说我们不愿意进行自动化测试或是自动化测试实现太难，而是相对于手工操作还是太耗时间了。编写面面俱到的自动化脚本也会导致日后维护非常困难，一般来说，维护脚本的时间要占了自动化测试人工时间的70%以上，我们在对自动化的测试内容选择时要有一定的取舍。

举个栗子。

比如这个移动互联的任务管理系统。大家看一下这个我们所在的人员信息配置页面有哪些功能模块。
这是我们公司很典型的管理系统，做web测试的基本天天都要面对这种界面，而且它的操作也很典型。
就是最基础的增删改查。
集成测试是系统层面的测试，需要测试直接面向用户操作的功能，如果要实现自动化，我们最好是选择一条较长，而且能代表主功能的操作来编写用例。
我们可以简单的把功能分成这些模块，红色框是查询功能能，蓝色框是对单条信息的处理，紫色框也是对单条信息的删除操作，
但是和蓝色框还是有点区别，因为我们在新建，查看，编辑成员信息时会有弹窗，有具体的数据操作，而这部分很可能有可重用的操作。
而紫色框直接删除即可。

如果我们要进行冒烟测试，蓝色框一定是最先考虑的，然后紫色也很重要。然后是红色的查询功能，最后是翻页。我们在有限时间内编写自动化脚本时要分清优先级，提炼出最重要的步骤，这样能快速自动化，也避免了日后在维护脚本时花大量的时间。

我们看到，工作中，系统层面的自动化测试受到上述影响，我们针对这些因素总结出我们的自动化需求。
首先是提炼出主流程，只对重要用例实现自动化，比如刚才的系统，在冒烟层面上，我们只要增删改查功能正常即可，也就是实现右图所示的步骤，如果有时间，后续可以把剩下的功能再增加上。
然后就是我们的自动化只用来冒烟测试和回归测试，特别细的操作我建议还是手工测试。这部分的自动化成本太高。
最后就是快速编写和反馈准确。以适应高速的迭代和重复工作。

那么我们有了目标和方向，下面就该选择方法来确定可行性了。
首先我们来看大名鼎鼎的selenium，selenium是web自动化最有名的测试工具。
虽然都能操作浏览器让他自动运行某些测试用例，但是却有三个实现方式，seleniumIDE，selenium1和selenium2。来看我使用过后对他们的评价，seleniumIDE，是最快捷的测试方式，而且也是最好理解的测试方法，他是firefox的插件，安装了就能用，支持脚本录制，上手容易。编写时不用写代码，只要写些命令就行。
然后是selenium1，它有个nodejs的实现，名叫苏打。
怎么理解这个nodejs呢，
那么Node是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。V8在非浏览器环境下运行得非常出色。
简而言之就是javascript以前只能运行在浏览器环境下，现在我们可以通过nodejs运行在后台。
对我们selenium意义就是，
以前我们要用selenium1自动化测试，只能写C#，写Java，写python。现在我们用了这个soda，就可以用javascript来进行自动化测试了。写javascript来测试用javascript写的前端功能，应该是每个前端人员都愿意看到的事。
那么再说selenium1，它的代码模拟浏览器的javascript操作，所以能支持更多的浏览器，然而这一特点也导致了它的缺点，每一个浏览器对于执行javascript都有很严格的安全限制，以防用户被恶意脚本攻击。导致了selenium1在某些场景下的测试工作变得困难，尤其是比较古老的IE浏览器这些。
而selenium2用了和selenium1完全不同的操作浏览器的方式，selenium2最重要的技术是webdriver，它是一个外部过程，不会受到浏览器安全限制，会获得更多的控制权。然而它的特点同样也导致了它的缺点，就是浏览器支持没有selenium1多。
我们在权衡这三者时要考虑到这些问题。

这是他们三个实现同样功能的代码或是操作方式。

大家觉得，依照我们自动化测试要求，就是快速编写，快速冒烟回归。操作简单的前提下我们该选择哪一种。
没错，三者都行。但是如果要非得说一个最快捷，最方便的，我们还是得用IDE来进行我们的测试。
当然，selenium不是我们集成测试的唯一选择，运行在phontomJS之上的casperJS也是一个优秀的选择，他们的名字两个都是小幽灵。为什么这么叫我们在后面会说，我们只要知道，casperJS也能操作phontomJS进行自动化集成测试就行。它的优点和缺点有兴趣的人可以自己深入了解下。

下面我们来看selenium脚本怎么写。
我们对于selenium要有左边所示的知识。了解元素定位方式是前端知识的基础，selenium提供了很多的定位方式，能让我们快速找到目标元素，当然实在找不到的话，也可以自己录制嘛。
步骤可以自由选择手写或录制，其实测试具体步骤编写是最简单的部分，最麻烦的其实是对记录下的状态进行分析，给出结果。
来看看selenium的界面，我们可以执行单个用例，也可以执行整个的测试套件组。相关结果会输出在log部分，右上是录制开关，中间是测试步骤，下面是每一步的具体的参数设置。
图中这个命令大家看的清吧？
commend是命令，target是目标，value可以存储值。这里只用到了两个参数，意思就是点击了id为
createUser的按钮。从命令上可以知道，我们是点击了刚才那个页面的新建用户的按钮了。

现在我们有了知识储备，我们需要有一个脚本的编写思路。我总结为这三点，数据驱动，过程从简状态记录，结果处理，自定义输出。
来看根据这思想编写出的脚本。

【可以先执行下脚本让大家看下运行情况，需要对结果进行说明】

首先我们把所有要用到的数据都写在开头，这样便于维护，而且我们通过修改初始值，不关心过程，直接看结果就能判断出我们的系统有没有问题。
然后将步骤精简，我推荐，应该说是建议所有的步骤都手写，录制有时候会记下一些多余的操作，这不是我们所需要的，只要对操作步骤清晰，编写步骤是很简单的。
而步骤的执行过程中，状态的记录永远是优先级最高的，比如我们新建一个用户前，我们要查找当前页面，使用stroeTextPresent命令查找用户名，会返回一个true or false，ture就是当前存在这个用户名，false就是不存在，然后我们新建用户之后再查询一次，把前后的状态记录下来，我们就可以判断我们的新建操作有没有正常实现。预期中，新建前一定是没有这个用户的，新建之后就会有。满足这个条件，我们的新建功能就成功了。
可以预见到，我们的大部分工作都会放在对状态的处理上，我们可以使用javascript语句对状态进行操作，比如这里用三元操作符，对状态成功与失败分别进行了处理，自定义了输出。当所有的测试项都通过的时候，就会有冒烟通过的提示。
我们的脚本都应该遵循这种模式来编写，这也是最易维护的脚本模式。

左边是一些常见的selenium命令，可以稍微看下，open是打开指定页面，click是点击，type是填充输入框，select是下拉框选择，pause是操作暂停多少秒，echo是打印输出。
后面的值存储和断言都是需要掌握的命令，他们一定程度上相通，掌握起来也很容易。

集成测试我们就到这里，通过一个案例来实现了简单的自动化。
我建议每个测试人员都能将这个用到项目里。哪怕只是简单得进行冒烟测试。敢于实践是很重要的，如果你们在实践中遇到了什么问题欢迎来交流。


下面我讲讲性能。
性能这东西，讲起来还真不是今天能讲的完的。
这种东西开发优化起来远远比测试困难很多倍，它也是需要经验的积累才能做的好的。
我记得我看过一篇文章教程序员如何学坏，里面很重要的一点就是，千万别给自己做性能测试。
可见这东西的麻烦程度。
我决定把它一笔带过。只提供一些测试工具和方法，以及代码层面上的优化思路。
来看测试工具，我们可以用firefox插件，有名的yslow来做，它还自带页面评分。给你的页面打A,B,C,D,E这些等级。能给出基于yahoo规范的优化建议。还内含小工具，对js和css做一些简单的处理。总之这是个很有意思的插件，可以一试。
此外，F12，chrome都能查看一些很重要的图标信息。
还有基于nodejs的请求模拟工具可以测负载。如果不限制javascript语言，工具就更多了，loadrunner，jemeter，都是很有用的性能测试工具。
其实只要开发人员在基础代码层面上注意到了某些细节问题。就能避免了不少的性能问题。
【以创建dom节点为例，我们一般都是用字符串直接写html来创建节点，其实这样做无法保证代码的有效性，而且字符串操作效率也很低，所以使用原生createElement()方法或cloneNode()方法比较好】
这个就不深究了，其实开发最重要的还是功能的实现能力，性能永远都是最后或是靠后考虑的，
相关提升性能的编码建议查看下相关的编码规范就行了。

【看下时间，那么我们把下面这一节讲完就休息下好吧。】

下面是一个相对容易理解的环节，代码注释。
在谈及代码注释之前，我们先来看看下面三个能将代码注释转换为API文档的javascript自动化文档工具。他们能对代码中的按照固定格式书写的注释进行解析，生成特定的便于阅读的文档。

首先是yui的这个工具，这个属于大名鼎鼎的yui，前端的标杆。
他和JSDuck都清晰易读，具全局搜索。但因为并不只支持javascript，所以为了多语言兼容，它并不解析实际代码，仅解析注释块部分。
其实就是说它只认注释块的内容。你代码和注释天差地别它都不管。只要按照它的规定写注释，它就给你生成高大上的API文档。

再看看JSDuck，它介于yui和后面jsdoc之间，能解析一定的js代码。而JSDoc则是严格解析代码，有一点不符合它的语法规定就不能正常生成文档。
对于javascript这种灵活的语言来说，为了生成注释文档，而修改原代码实在有点矫枉过正。

那么会有人问我们用的是yui还是jsDuck，这要是考试选择题，大部分人都会选jsDuck。

其实三者都行，因为我们目标毕竟不是专门生成API文档，
我们需要的是规范的注释。
在当前对文档API易用性要求不高，也就是说，我们需要遵循的是他们的注释规范而不是使用工具，当然，后期的时候另说。
那么我们用yui举例来看YUI的使用方法与注释标准。
首先下载安装nodejs环境。然后将yuidocjs安装到全局环境里。加了参数g就是安装进全局里。
而这个npm是nodejs的包管理工具，它会将指定的包安装进你的文件夹里。
最后在我们存放js代码的文件夹下运行命令，就会生成一个名为out的文件夹，其中的index.html就由右图所示。
可以看到，
这个文档是由左下的js注释生成的。也就是说，只要按照yui的规范写注释。就给你个高大上的文档。
我们使用yui注释需要按照如下步骤。
首先，注释要以/**开始，*/结尾。如果有大段要写的介绍，或仅仅想写废话，就在开头写。
然后是每个注释块仅有一个的主标签，除了这里用来定义方法的主标签，yui还有描述构造方法的主标签，和类似method的，但是没有参数返回的函数标签event，以及用来描述类的属性的主标签property。
主标签之后是副标签，用于说明主标签，以这里的method为例。
它就用了@params和@return副标签加以说明，表明该方法所需的参数和期望的返回。
【然后解释一番这个捏造的方法】

我们在一个项目中要选择遵守上面三个注释规范中的一个。
如果开发中不能照顾全部代码。那么必要要保证所有的公用方法都被注释。

【要休息么。不休息的话我们就一下子讲完，后面是重点】
【稍作休息，我们待会来进入一个比较枯燥，但其实很有趣的环节，单元测试。
顺便说下目前我们单元测试的要求，就是开发人员来做，但是要求测试人员能看的懂测试代码。并对测试结果跟进，能对单元测试的代码提出优化建议，帮助开发提升代码质量】



好，我们来说说单元测试，大家对单元测试或多或少都有自己的见解了，那我们直奔主题。
单元测试，最难的部分其实就是开头，我们需要大量的样板代码来构建整个系统，当系统搭建好了之后其实我们只需要按照傻瓜式的语法对被测代码写写断言就行了。
稍后我会结合流行的javascript测试框架提出目前适合我们的测试方案。

所以我们知道了，单元测试最重要的是将测试聚合到测试套件和测试用例中。需要一套整合被测代码，测试用例代码的架构。一套有条理的框架尤为重要，这个等下说。
然后同样重要的一个部分是断言，结合之前的selenium自动化脚本编写经验。我们发现，在操作步骤的编写上并没有花费多少时间，
但是我们通过对状态的记录，断言结果的判断，自定义出了完备详细的规范输出。
所以断言是单元测试的基石，需要我们重点掌握。
那么我们还要记住的一点，就是单元测试必须由开发人员来推动，开发人员需要比谁都熟悉自己的代码最基础的模块。然后通过编写单元测试来再次熟悉代码和函数逻辑。将系统的基石打牢靠。

那么我们来看看单元测试编写要点。
隔离，就是说单元测试应该只加载所需测试的最小化代码进行测试。其实大部分情况下，单元测试只有一个方法，等下我们会对一个方法例子做分析。
范围呢要求小。
继续看，刚才我们所提及的代码注释现在立马显现出作用了。我们在需要编写单元测试时完全可以通过之前的注释来给函数下一个定义，准确描述该函数功能。基于这个功能来展开编码工作。编写良好单元测试的第一准则就是有一个完全规范定义的函数。
第四点是最简单最常见的正向测试，这个不说明了，大部分测试。包括大家常干的黑盒，这也是最简单最常见的测试验证方式。
负向测试，和正向想法，需要注意的是他因为涉及了注释之外的内容，所以易找出难以对付，预料之外的bug。
然后是代码覆盖率，它必须是工具自动生成，禁止一切的人工干预。

那么我们接下来就看看最困难的也是最接近实际的一点，如何测试真实场景。

我们工作中遇到的代码，不可能就是老生常谈的右上角这个sum函数，如此理想，没有依赖，参数明确，返回明确，条理清晰。

在编写测试代码前首先我们就得处理一系列的函数依赖，我们通过模和桩来提取依赖关系。
模用来模拟不宜构造或不易获取的对象，而桩是用来向被测函数返回所封装的值。
当模拟好了依赖，就是说不需要外部对象，也不依赖外部数据的时候。也就是完成了隔离，剩余的事情就是对隔离代码编写单元测试了。

当然到这里还没完，编写测试代码的过程中我们又遇到了一个问题，异步。
异步是javascript语言的一个重要特性，就是拥有一个回调函数，实现控制反转。
要深入比较麻烦，我们可以直接看测试所要面临的情况，就是异步测试时我们会要暂停测试流程，等待事件触发，然后在事件处理程序中在恢复流程。
这个过程中可能还要抛出一两个断言。
解决方案相对的也很多，比如使用支持异步测试的框架，比如后面要说的mocha。
但我建议，如果涉及深层嵌套，尤其是前端复杂的具体业务逻辑时，还是放弃对这一部分代码进行单元测试，
改用一开始提及的selenium集成测试。我们要意识到，单元测试的条件很苛刻，某些情况下更会脆弱不堪。开发在编写单元测试是，懂得取舍，也是重要一个点。


那么下面我们就要开始javascript单元测试了，我们使用的会是强大的phontomJS。
现在我们重新介绍下phontomJS，它是无头模式的webkit浏览器，所谓无头模式，就是说他跟本没有可视界面，
有人就会奇怪，你们说一个浏览器没可视界面，听起来就像是食堂里面不提供坐的地方一样。
实际上并非如此，没有界面是劣势同时也是优势。使得phantomJS在无需显示页面的网页抓取，测试方面广泛运用。
就是说它的确是个不提供座位的食堂，因为他主营业务其实是外卖是吧。

那么再看看mocha，抹茶是个基于node.js，集合了各种特性的javascript测试框架。
可以搭配如shouldJS或Chai等断言库。接近自然语法的断言库使得我们的单元测试简单易读，
正常的开发人员在搭建好环境和框架后基本2分钟就能编写单元测试代码。

我们来看语法。抹茶这个框架提供了三种测试风格的接口，行为驱动开发BDD，测试驱动开发TDD和Exports。
所谓行为驱动开发，我们不妨先看这个样例的代码语法。
首先我们描述了一个用例组，这个组是用来测试数组Array的，在开始测试前我们可能有一些准备工作，
然后内部再分组，我们要测试数组的indexOf方法。这其中就能涉及到具体测试用例了，比如BDD模式就用简洁的自然语言描述系统行为。这里这么写到，数组[1,2,3]执行indexof(4)方法会返回-1。这个indexOf本身的作用是遍历一个数组，返回参数所在的位置。这个数组里面并没有4这个数，对于没有结果的就返回-1。可以看到，我们用自然语言描述了这个函数应有的行为，当这个函数行为和预期不符的时候，我们的单元测试结果就会报错。
BDD的核心价值是体现在正确的对系统行为进行设计。强调的是系统最终的实现与用户期望的行为是一致的、验证代码实现是否符合设计目标。
如果对函数的功能有准确的预期，那么BDD模式就能完美设计出完善的测试用例。其实TDD也可以和BDD一样，他们只是思路上的不同，在表现上是完全一致的，比如这个用例用TDD来说，suite就是describe，test就是it，setup就是before。
往下的export也是一样，他们功能都是重合的。就是测试思路的差别。我们建议使用BDD模式测试，这种模式最直观，也方便测试人员干预。

举个例子，我们如何通过单元测试提升代码质量。

这里是一个斐波那契函数，1,1,2,3,5...后面每个数都是前两个数的和，我们代码简单实现如上。传入的参数为0，返回0，传入1，返回1，往后传入什么值都是递归实现，为前两个数的和。
那么如果我们写测试用例我们可以就这么写。如预期一样。是三个测试项。
这时候测试就会蹦出来提意见，就没有异常情况？
没错，这个函数的测试用例太浅显了，并没有考虑特殊情况，我们没有考虑为0的情况，没有考虑参数是字符的情况，我们什么都没考虑。
于是我们测试编写了详尽一点的测试用例，基于这个用例写了单元测试，然后一跑结果，这个函数就爆了一大堆的错误。
开发看见了这还得了，赶紧加班加点的把原代码给补全了。我们就从测试角度，基于对这个函数的行为期望，帮开发把代码进行了完善。

我们有了工具，也知道了具体的实现方法。就是重中之重了，测试架构的搭建。
单元测试由于其分散而细致的特性，把被测代码和测试代码组织起来尤为重要。
这部分是重点，而且做好了之后会让整个单元测试的结构豁然开朗。后续的人只需要在现有的框架下按照规则编写测试代码运行就可以。

我总结出的搭建方法是html展现和requireJS结合。这种方式的测试结果简单易读，可扩展性强。可以根据需求自由选择测试项。

我们首先来看文件架构图。最外面的是两个大文件夹，js文件夹是我们项目的前端源代码的目录。testJS就是我们的测试文件夹。里面的test是源代码的镜像树。放置着一一对应的测试js文件。
然后是node_modules，这个基于我们的package.json生成，了解过nodejs的都会知道。它里面是我们这个测试框架所用到的第三方库，比如mocha，should，chai，对了，我们的mocha-phantomJS已经安装在全局环境中了，所以这里没有。然后是scripts文件，放些html文件可能会用到的交互代码和第三方代码。在后期的功能扩充中作用很大。最后是我们的展示页和入口js文件。

打开这个start.html就会自动运行出结果。来看看这个框架如何运行出结果的。
首先，在start.html中我们引入了mocha框架。将它设置为bdd模式，并用html输出结果。在这里我们为了模块化我们的整个测试框架引入了requireJS，这是个遵循AMD规范的文件加载器，我们可以按需加载我们配置过路径的测试文件。在这里我们将它配置一下，可以看到在testConfig.js中我们配置了初始路径和路径别名。之后的按需加载主要就是按照别名来加载的。
配置完成后，我们就进入了测试入口文件。在这里面顶部define函数里，需要运行什么测试文件就将该文件的名字填进来。这里我们要运行demo_test文件，于是我们运行了demo_test，然后作为一个单元测试文件，它又需要加载我们的被测代码文件，于是还是在顶部，加载了demo文件。
于是流程串通，我们在最初的start.html里面就能看到针对demo代码文件，用demo_test测试后的结果。这个框架就是最基础的requireJS和mocha的页面结果模式的结合，是我分析出的最适合目前前端单元测试的框架，它可扩展性非常好，我们要测试什么文件，隔离后的被test文件所调用，然后在入口js中把test文件引用一下就行了。如果按照我们的文件架构来做，这个过程会更为有条理。
【我们实际运行下这个框架看看】
我们在入口文件中引入了三个测试文件，demo_test.js，common_test.js，nove_test.js，他们又各自调用了被测文件demo，common和novel。然后就得到了所示的结果。
这个html结果可以简单集成进其他系统中。本身可读性非常强，再回到我们的PPT，刚才的运行结果便是这些文件所运行出来的。我们还可以命令行中运行，但这个易用性就远不如文档形式了。

单元测试总体来说还是简单的，就是初期投入会比较大，但是能得到丰厚的回报。能对整个项目的规范程度起一个质的提升。



那么我们进入今天最后，也是可能最抽象的一个环节，提升代码质量，进行优化。
我们通过探讨优秀的代码是什么样子的，来形成代码优化的意识。

这个内容我觉得大家可以找些书看看，比如编写可测试可维护的javascript代码。这种需要积累和直观认知的抽象知识总是不好理解的。

来看优秀代码的第一个特点，与其说是保持最小代码量，应该说是用功能分离的方式将函数细分，将doSomething功能的命令函数和returnSomething功能的查询函数所分离。一个大的函数分解为功能更单一的小函数，可以准确的用模，或桩来进行模拟。能有效的保证函数功能专一，便于编写单元测试。
第二个特点，保持代码合理性，意思是代码需要规范，一些语法容许，但是并不是优秀书写方式的代码需要改进。如这里列举出来的，分号是必须的，哪怕是能省略的。if和for语句也必须使用大括号括起等等。。我们可以用一些javascript合理性检测工具来进行检测。辅助提升我们的代码合理性。
第三个特点，就是圈复杂度要低。圈复杂度是代码独立现行路径数量，有多少独立路径我们至少就要写多少单元测试，这是必然的。降低圈复杂度的思路也是函数细化，避免高复杂度函数的出现。左图工具同样能辅助我们查看代码的这些信息。
第四个特点，就是代码重用，不知道是哪位程序员，反正是个很厉害的程序员曾经预估到，一个系统只有15%的部分是独有的。剩下的基本都是大框架和实现特定功能的第三方库。也就是所谓的领域独立的代码和特定领域的代码。我们在开发过程中要使用前辈的精华，避免重复造车，专注我们的特定的程序代码。将我们的部分做好，整个系统就会变得优秀。
第五个特点名叫扇出，它代表着函数直接或间接依赖的模块或对象的数量，标准定义如下。
其实说人话就是调用了其他模块，有交互了呗。
再说明白点就是依赖。
【叹气，又要看代码了哎，大家看不看？】
【看是吧？那我们来看这个例子，我希望我能把讲明白。】
看这段代码，其实我是很讨厌不喜欢看外国程序员写的书的，因为他们总是把一些他们认为很简单东西写给英语水平不过关的我们，比如这个例子，上来就是一堆一眼看不明白的单词，其实翻译过后是很简单的东西。
这是个做鸡肉大餐的方法，我们传递参数是香料，然后里面准备了鸡脯肉，准备了烤炉，准备了混合器。然后混合食物，最后把混合过的食物，再一个温度控制器和时间控制器的操控下烘焙五十分钟。得到鸡肉大餐。
如何评价这个函数呢？
我们很简单的就能得到结果，它依赖太多了，用了五个外部对象，鸡脯肉，烤炉，混合器，温度控制器，时间控制器。还用了烤炉和混合器的方法。可以说是在函数内部用了太多的外部的东西。
所以我们的测试代码要这样写，外部准备就要耗掉大部分时间，我们要用模准备以上五个对象并一个个实例化他们，相比对一个单一方法进行单元测试，模拟和替换上述对象是非常大的工作量。容易出问题，我们必须要重构它，让他可测试。

那么直接看重构后的代码吧，可以看到，这个做大餐的函数的参数增加了一个厨具，也就是说这个函数简化了，我们这次只要传香料和厨具就能开始烹饪。这个厨具就是一个外观，它还封装了温度调节和时间控制的功能，把这个外观注入进函数里就减少了大量的扇出。
现在这个函数仅有两个紧耦合，基于重构后的代码我们的测试方法描述如下，外部只需准备一些鸡肉食材，测试时则准备我们的参数就行了，也就是厨具和香料，准备好了就能开始测试。

遵循这个思想，我们还可以把这个方法再次精简，这次可以看到，我们把鸡肉和混合器也变成了注入，这个函数变得更简单无脑，传递给我上述参数，我就返回一个食物，而不用在函数里面新建这个对象新建那个对象。我们测试代码模拟参数就能完全掌控传入的模拟对象，让代码具备了更大的灵活性。
可以看到我们测试方案的描述更为简单了，测试代码占绝对主导，外部准备工作已经完全不需要了。

那么我们看看是第几个特点了，第六个是扇入，简单来说就是被依赖。高扇入说明重用的比较多，这可能是好事也是坏事，大家自行判断。

第七个是耦合，耦合常常和扇出一起说，它和扇出关注依赖数量不同，耦合关注的是他们组合在一起的方式，内容耦合，公共耦合，控制耦合，印记耦合，数据耦合，到无耦合，耦合程度从高到低。一般和扇出一起进行优化。

最后就是依赖和注入。我们在函数内部少用依赖，多用注入。什么意思呢，就是我们函数不自己引用外部对象，我要什么你给我就行了，至于外面你们是怎么做的我不管，只要我本身简单易懂就行了。


好了，差不多要到结尾了，我们再来探讨下一些很笨但是必须要面对的问题。
yes or no，我们的测试，尤其是一些相对比较麻烦的测试，如单元测试，要不要做。
有些人这么说出了现状和心里所想，我觉得很有趣。
我们都意识到要这么做，但我们都不确定怎么做，大多数人都没有做，但是呢，我们都非常支持这么做。
问题答案每个人都有底了吧。
我们再看这个工作由谁来做呢？
根据我对今天所述的这些测试工作的理解，我是如下分工的。
代码优化和注释本来就是开发的事，测试投入10%用工具跟踪。
单元测试由开发主导，测试投入30%对测试代码进行维护和反馈。
集成测试和性能测试由测试主导，开发对测试工作提供支持即可。

那么我们的分享的最后还是把今天所说的总结为两句话把。开发们，编写可测试的javascript代码。测试们，则是从代码到系统，执行尽可能完备的测试。最终目标永远都是提升项目质量。

那么分享就到这里了，以下是我的联系方式，如果有兴趣交流的话私下可以交流下。
现在，就当前。有没有人有问题？

【关于我今天所说的】
【没有问题的话我们就到此为止，好吧】


